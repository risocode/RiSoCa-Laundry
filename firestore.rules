/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user-specific data, including profiles,
 * addresses, orders, and notifications, is nested within a user-specific document tree. This ensures that a user can
 * only ever access their own information.
 *
 * Data Structure:
 * - /users/{userId}: A collection storing individual UserProfile documents.
 *   - /addresses/{addressId}: Subcollection for a user's addresses.
 *   - /orders/{orderId}: Subcollection for a user's orders.
 *   - /notifications/{notificationId}: Subcollection for a user's notifications.
 * - /services/{serviceId}: A top-level collection containing public information about available laundry services.
 *
 * Key Security Decisions:
 * - User Data Privacy: All data under `/users/{userId}` is strictly private and can only be accessed by the
 *   authenticated user whose UID matches the `{userId}` wildcard.
 * - No User Listing: To protect user privacy, it is not possible for any client to list all documents in the `/users` collection.
 * - Public Service Data: The `/services` collection is publicly readable by anyone, including unauthenticated users,
 *   to allow browsing of available services.
 * - Admin-Managed Data: Writes to the `/services` collection are disabled for all clients. This data is assumed to be
 *   managed by administrators using the Firebase Admin SDK.
 *
 * Denormalization for Authorization: The security model heavily relies on "path-based ownership." By including the
 * user's UID in the document path (e.g., `/users/{userId}/orders/{orderId}`), we create simple, fast, and secure rules
 * without needing to perform extra `get()` calls to check ownership. Relational integrity is maintained by ensuring that
 * internal `userId` fields on documents match the `userId` in the path.
 *
 * Structural Segregation: The ruleset leverages structural segregation by separating private user data (`/users/{userId}`)
 * from public application data (`/services`). This separation creates a homogeneous security posture within each collection,
 * simplifying the rules and enhancing security and performance for list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * isSignedIn
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * isOwner
     * Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * isExistingOwner
     * Checks if a document exists and if the authenticated user is the owner.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return resource != null && isOwner(userId);
    }
    
    /**
     * isNewUserProfile
     * Validates the creation of a new user profile document, ensuring the
     * document's internal ID matches the user's auth UID.
     */
    function isNewUserProfile(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }
    
    /**
     * isImmutableUserId
     * Ensures the internal 'id' field of a user profile cannot be changed on update.
     */
    function isImmutableUserId() {
      return request.resource.data.id == resource.data.id;
    }
    
    /**
     * isNewOwnedDocument
     * Validates creation of a subcollection document, ensuring its internal
     * `userId` field matches the owner's UID from the path.
     */
    function isNewOwnedDocument(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }
    
    /**
     * isImmutableOwnerLink
     * Ensures the internal `userId` field of a subcollection document cannot
     * be changed on update.
     */
    function isImmutableOwnerLink() {
      return request.resource.data.userId == resource.data.userId;
    }

    //-------------------------------------------------------------------------
    // User Data
    //-------------------------------------------------------------------------

    /**
     * @description   Manages user profile documents. A user can create their own profile,
     *                but can only read, update, or delete their own existing profile.
     * @path          /users/{userId}
     * @allow         (create) A newly signed-up user (auth.uid: 'user123') creating their own profile at `/users/user123`.
     * @deny          (get) User 'user123' trying to read the profile at `/users/user456`.
     * @principle     Enforces self-creation and strict document ownership. Prevents user enumeration via `list`.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isNewUserProfile(userId);
      allow update: if isExistingOwner(userId) && isImmutableUserId();
      allow delete: if isExistingOwner(userId);

      /**
       * @description   Manages a user's saved addresses. Only the owning user can manage their addresses.
       * @path          /users/{userId}/addresses/{addressId}
       * @allow         (list) User 'user123' listing all documents in `/users/user123/addresses`.
       * @deny          (update) User 'user456' trying to update an address in `/users/user123/addresses/{addressId}`.
       * @principle     Restricts access to a user's own data tree and validates relational integrity.
       */
      match /addresses/{addressId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isNewOwnedDocument(userId);
        allow update: if isExistingOwner(userId) && isImmutableOwnerLink();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description   Manages a user's laundry orders. Only the owning user can manage their orders.
       * @path          /users/{userId}/orders/{orderId}
       * @allow         (create) User 'user123' creating a new order at `/users/user123/orders/{orderId}`.
       * @deny          (get) An unauthenticated user trying to read any order document.
       * @principle     Restricts access to a user's own data tree and validates relational integrity.
       */
      match /orders/{orderId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isNewOwnedDocument(userId);
        allow update: if isExistingOwner(userId) && isImmutableOwnerLink();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description   Manages notifications for a user. Only the owning user can manage their notifications.
       * @path          /users/{userId}/notifications/{notificationId}
       * @allow         (delete) User 'user123' deleting a notification at `/users/user123/notifications/{notificationId}`.
       * @deny          (list) User 'user456' trying to list notifications from `/users/user123/notifications`.
       * @principle     Restricts access to a user's own data tree and validates relational integrity.
       */
      match /notifications/{notificationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isNewOwnedDocument(userId);
        allow update: if isExistingOwner(userId) && isImmutableOwnerLink();
        allow delete: if isExistingOwner(userId);
      }
    }

    //-------------------------------------------------------------------------
    // Global Data
    //-------------------------------------------------------------------------

    /**
     * @description   Stores laundry services available to all users. This data is public to read but
     *                cannot be modified by clients. It is managed by backend administrators.
     * @path          /services/{serviceId}
     * @allow         (get, list) Any user, including unauthenticated ones, can read service details.
     * @deny          (create, update, delete) Any client trying to modify the list of services.
     * @principle     Provides public read access for global data while securing it against unauthorized modification.
     */
    match /services/{serviceId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}